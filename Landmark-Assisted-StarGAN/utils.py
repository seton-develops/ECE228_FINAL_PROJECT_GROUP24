'''
@AUTHOR:  Zeting Luan
@DATE: 6/8/22
@DESCRIPTION: Three utils functions for the networks.
The first two are for save and load checkpoint, so we can always stop and continue training.
The calculate_error_norm function is for calculating the landmark consistency loss during training.
'''
import random, torch, os, numpy as np
import torch.nn as nn
import config
import copy


def save_checkpoint(model, optimizer, filename="my_checkpoint.pth.tar"):
    '''
    Save checkpoints if you set the CONFIG.SAVE_MODEL = TRUE
    INPUT:
        model: the model you want to save
        optimizer: the optimizer you want to save
        filename: the filename from config.py
    '''
    print("=> Saving checkpoint")
    checkpoint = {
        "state_dict": model.state_dict(),
        "optimizer": optimizer.state_dict(),
    }
    torch.save(checkpoint, filename)


def load_checkpoint(checkpoint_file, model, optimizer, lr):
    '''
    Save checkpoints if you set the CONFIG.LOAD_MODEL = TRUE
    INPUT:
        checkpoint_file = the name of your checkpoint file, it should be consistent with filename in save_checkpoint
        model: the model you want to load
        optimizer: the optimizer you want to load
        lr: the learning rate at the stage when you saved your checkpoint
    '''
    print("=> Loading checkpoint")
    checkpoint = torch.load(checkpoint_file, map_location=config.DEVICE)
    model.load_state_dict(checkpoint["state_dict"])
    optimizer.load_state_dict(checkpoint["optimizer"])
    for param_group in optimizer.param_groups:
        param_group["lr"] = lr


def calculate_error_norm(y_true, y_pred):
    '''
    Calculate the L-2 distance between landmark label and the predicted landmark .
    INPUT:
        y_true: landmark label from dataset
        y_pred: landmark generated by the regressor
    OUTPUT:
        result: The L-2 distance between y_true and y_pred
    '''
    result = np.zeros((y_true.shape[0], 5))
    ioc = np.sqrt(np.square(y_true[:,0] - y_true[:,1]) + np.square(y_true[:,5] - y_true[:,6]))
    for i in range(5):
        result[:, i] = np.sqrt(np.square(y_true[:,i] - y_pred[:,i]) + np.square(y_true[:,i+5] - y_pred[:,i+5])) / ioc
        # Since the csv file has the format of x_eyes, y_eyes,... we need to make sure the coordinates match with each other. 
    return result
